{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// Define the initial state with additional properties\nconst initialState = {\n  workers: [],\n  totalCapacity: 0,\n  averageAttendance: 0,\n  averageCPH: 0,\n  averageUptime: 0,\n  headCount: 0,\n  status: 'idle',\n  // 'idle' | 'loading' | 'succeeded' | 'failed'\n  error: null\n};\n\n// // Async thunk to fetch metrics\n// export const fetchMetrics = createAsyncThunk('metrics/fetchMetrics', async () => {\n//   const response = await fetch('http://localhost:5555/associate_metrics');\n//   const data = await response.json();\n//   return data;\n// });\n\n// updateWorkerMetrics: (state, action) => {\n//   const { workerId, newMetrics } = action.payload;\n//   // Find the worker in the state and update their metrics\n//   const workerIndex = state.workers.findIndex(worker => worker.id === workerId);\n//   if(workerIndex !== -1) {\n//     state.workers[workerIndex].metrics = newMetrics;\n//     // Recalculate the global metrics\n//     const calculatedMetrics = calculateMetrics(state.workers);\n//     return { ...state, ...calculatedMetrics };\n//   }\n// },\n\n// Extract and calculate metrics from worker data\nconst calculateMetrics = workers => {\n  let transformedWorkers = workers.map(worker => {\n    var _worker$metrics$find, _worker$metrics$find2, _worker$metrics$find3;\n    return {\n      attendance: ((_worker$metrics$find = worker.metrics.find(m => m.metric_name === 'Attendance')) === null || _worker$metrics$find === void 0 ? void 0 : _worker$metrics$find.value) || 0,\n      casesPerHour: ((_worker$metrics$find2 = worker.metrics.find(m => m.metric_name === 'Pallets Per Hour')) === null || _worker$metrics$find2 === void 0 ? void 0 : _worker$metrics$find2.value) || 0,\n      uptime: ((_worker$metrics$find3 = worker.metrics.find(m => m.metric_name === 'Uptime')) === null || _worker$metrics$find3 === void 0 ? void 0 : _worker$metrics$find3.value) || 0\n    };\n  });\n  let averageAttendance = transformedWorkers.reduce((sum, w) => sum + Number(w.attendance), 0) / (transformedWorkers.length || 1);\n  let averageCPH = transformedWorkers.reduce((sum, w) => sum + Number(w.casesPerHour), 0) / (transformedWorkers.length || 1);\n  let averageUptime = transformedWorkers.reduce((sum, w) => sum + Number(w.uptime), 0) / (transformedWorkers.length || 1);\n  let headCount = workers.length;\n  let totalCapacity = headCount * averageAttendance * averageCPH * averageUptime;\n  return {\n    totalCapacity,\n    averageAttendance,\n    averageCPH,\n    averageUptime,\n    headCount\n  };\n};\nconst metricsSlice = createSlice({\n  name: 'metrics',\n  initialState,\n  reducers: {\n    // Reducer to manually set metrics\n    setMetrics: (state, action) => {\n      return {\n        ...state,\n        ...action.payload\n      };\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchMetrics.pending, (state, action) => {\n      state.status = 'loading';\n    }).addCase(fetchMetrics.fulfilled, (state, action) => {\n      state.status = 'succeeded';\n      state.workers = action.payload;\n      if (!Array.isArray(action.payload)) {\n        state.error = 'Data received is not an array';\n        return;\n      }\n      const newMetrics = calculateMetrics(action.payload);\n      state.totalCapacity = newMetrics.totalCapacity;\n      state.averageAttendance = newMetrics.averageAttendance;\n      state.averageCPH = newMetrics.averageCPH;\n      state.averageUptime = newMetrics.averageUptime;\n      state.headCount = newMetrics.headCount;\n    }).addCase(fetchMetrics.rejected, (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message;\n    });\n  }\n});\nexport const {\n  setMetrics\n} = metricsSlice.actions;\nexport const updateMetrics = workers => dispatch => {\n  const metrics = calculateMetrics(workers);\n  dispatch(setMetrics(metrics));\n};\nexport default metricsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","initialState","workers","totalCapacity","averageAttendance","averageCPH","averageUptime","headCount","status","error","calculateMetrics","transformedWorkers","map","worker","_worker$metrics$find","_worker$metrics$find2","_worker$metrics$find3","attendance","metrics","find","m","metric_name","value","casesPerHour","uptime","reduce","sum","w","Number","length","metricsSlice","name","reducers","setMetrics","state","action","payload","extraReducers","builder","addCase","fetchMetrics","pending","fulfilled","Array","isArray","newMetrics","rejected","message","actions","updateMetrics","dispatch","reducer"],"sources":["/home/samuelrcwade/Development/Code/Phase4/roster_management/client/src/features/metricsSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// Define the initial state with additional properties\nconst initialState = {\n  workers: [],\n  totalCapacity: 0,\n  averageAttendance: 0,\n  averageCPH: 0,\n  averageUptime: 0,\n  headCount: 0,\n  status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n  error: null\n};\n\n// // Async thunk to fetch metrics\n// export const fetchMetrics = createAsyncThunk('metrics/fetchMetrics', async () => {\n//   const response = await fetch('http://localhost:5555/associate_metrics');\n//   const data = await response.json();\n//   return data;\n// });\n\n// updateWorkerMetrics: (state, action) => {\n//   const { workerId, newMetrics } = action.payload;\n//   // Find the worker in the state and update their metrics\n//   const workerIndex = state.workers.findIndex(worker => worker.id === workerId);\n//   if(workerIndex !== -1) {\n//     state.workers[workerIndex].metrics = newMetrics;\n//     // Recalculate the global metrics\n//     const calculatedMetrics = calculateMetrics(state.workers);\n//     return { ...state, ...calculatedMetrics };\n//   }\n// },\n\n// Extract and calculate metrics from worker data\nconst calculateMetrics = (workers) => {\n  let transformedWorkers = workers.map(worker => ({\n    attendance: worker.metrics.find(m => m.metric_name === 'Attendance')?.value || 0,\n    casesPerHour: worker.metrics.find(m => m.metric_name === 'Pallets Per Hour')?.value || 0,\n    uptime: worker.metrics.find(m => m.metric_name === 'Uptime')?.value || 0,\n  }));\n\n  \n  let averageAttendance = transformedWorkers.reduce((sum, w) => sum + Number(w.attendance), 0) / (transformedWorkers.length || 1)\n  let averageCPH = transformedWorkers.reduce((sum, w) => sum + Number(w.casesPerHour), 0) / (transformedWorkers.length || 1)\n  let averageUptime = transformedWorkers.reduce((sum, w) => sum + Number(w.uptime), 0) / (transformedWorkers.length || 1)\n  let headCount = workers.length\n  let totalCapacity = headCount*averageAttendance*averageCPH * averageUptime\n\n\n\n  return {\n    totalCapacity,\n    averageAttendance,\n    averageCPH,\n    averageUptime,\n    headCount\n  };\n};\n\nconst metricsSlice = createSlice({\n  name: 'metrics',\n  initialState,\n  reducers: {\n    // Reducer to manually set metrics\n    setMetrics: (state, action) => {\n      return { ...state, ...action.payload };\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchMetrics.pending, (state, action) => {\n        state.status = 'loading';\n      })\n\n      .addCase(fetchMetrics.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        state.workers = action.payload;\n        if (!Array.isArray(action.payload)) {\n          state.error = 'Data received is not an array';\n          return;\n        }\n        const newMetrics = calculateMetrics(action.payload);\n        state.totalCapacity = newMetrics.totalCapacity;\n        state.averageAttendance = newMetrics.averageAttendance;\n        state.averageCPH = newMetrics.averageCPH;\n        state.averageUptime = newMetrics.averageUptime;\n        state.headCount = newMetrics.headCount;\n      })\n      .addCase(fetchMetrics.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.error.message;\n      });\n  }\n});\n\n\nexport const { setMetrics } = metricsSlice.actions;\n\nexport const updateMetrics = (workers) => (dispatch) => {\n  const metrics = calculateMetrics(workers);\n  dispatch(setMetrics(metrics));\n};\n\n\nexport default metricsSlice.reducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}