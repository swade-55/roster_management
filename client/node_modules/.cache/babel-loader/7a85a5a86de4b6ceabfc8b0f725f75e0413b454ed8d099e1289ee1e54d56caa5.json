{"ast":null,"code":"// import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// // Define the initial state with additional properties\n// const initialState = {\n//   workers: [],\n//   totalCapacity: 0,\n//   averageAttendance: 0,\n//   averageCPH: 0,\n//   averageUptime: 0,\n//   headCount: 0,\n//   status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n//   error: null\n// };\n\n// // // Async thunk to fetch metrics\n// // export const fetchMetrics = createAsyncThunk('metrics/fetchMetrics', async () => {\n// //   const response = await fetch('http://localhost:5555/associate_metrics');\n// //   const data = await response.json();\n// //   return data;\n// // });\n\n// // updateWorkerMetrics: (state, action) => {\n// //   const { workerId, newMetrics } = action.payload;\n// //   // Find the worker in the state and update their metrics\n// //   const workerIndex = state.workers.findIndex(worker => worker.id === workerId);\n// //   if(workerIndex !== -1) {\n// //     state.workers[workerIndex].metrics = newMetrics;\n// //     // Recalculate the global metrics\n// //     const calculatedMetrics = calculateMetrics(state.workers);\n// //     return { ...state, ...calculatedMetrics };\n// //   }\n// // },\n\n// // Extract and calculate metrics from worker data\n// const calculateMetrics = (workers) => {\n//   let transformedWorkers = workers.map(worker => ({\n//     attendance: worker.metrics.find(m => m.metric_name === 'Attendance')?.value || 0,\n//     casesPerHour: worker.metrics.find(m => m.metric_name === 'Pallets Per Hour')?.value || 0,\n//     uptime: worker.metrics.find(m => m.metric_name === 'Uptime')?.value || 0,\n//   }));\n\n//   let averageAttendance = transformedWorkers.reduce((sum, w) => sum + Number(w.attendance), 0) / (transformedWorkers.length || 1)\n//   let averageCPH = transformedWorkers.reduce((sum, w) => sum + Number(w.casesPerHour), 0) / (transformedWorkers.length || 1)\n//   let averageUptime = transformedWorkers.reduce((sum, w) => sum + Number(w.uptime), 0) / (transformedWorkers.length || 1)\n//   let headCount = workers.length\n//   let totalCapacity = headCount*averageAttendance*averageCPH * averageUptime\n\n//   return {\n//     totalCapacity,\n//     averageAttendance,\n//     averageCPH,\n//     averageUptime,\n//     headCount\n//   };\n// };\n\n// const metricsSlice = createSlice({\n//   name: 'metrics',\n//   initialState,\n//   reducers: {\n//     // Reducer to manually set metrics\n//     setMetrics: (state, action) => {\n//       return { ...state, ...action.payload };\n//     },\n//   },\n//   extraReducers: (builder) => {\n//     builder\n//       .addCase(fetchMetrics.pending, (state, action) => {\n//         state.status = 'loading';\n//       })\n\n//       .addCase(fetchMetrics.fulfilled, (state, action) => {\n//         state.status = 'succeeded';\n//         state.workers = action.payload;\n//         if (!Array.isArray(action.payload)) {\n//           state.error = 'Data received is not an array';\n//           return;\n//         }\n//         const newMetrics = calculateMetrics(action.payload);\n//         state.totalCapacity = newMetrics.totalCapacity;\n//         state.averageAttendance = newMetrics.averageAttendance;\n//         state.averageCPH = newMetrics.averageCPH;\n//         state.averageUptime = newMetrics.averageUptime;\n//         state.headCount = newMetrics.headCount;\n//       })\n//       .addCase(fetchMetrics.rejected, (state, action) => {\n//         state.status = 'failed';\n//         state.error = action.error.message;\n//       });\n//   }\n// });\n\n// export const { setMetrics } = metricsSlice.actions;\n\n// export const updateMetrics = (workers) => (dispatch) => {\n//   const metrics = calculateMetrics(workers);\n//   dispatch(setMetrics(metrics));\n// };\n\n// export default metricsSlice.reducer;","map":{"version":3,"names":[],"sources":["/home/samuelrcwade/Development/Code/Phase4/roster_management/client/src/features/metricsSlice.js"],"sourcesContent":["// import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// // Define the initial state with additional properties\n// const initialState = {\n//   workers: [],\n//   totalCapacity: 0,\n//   averageAttendance: 0,\n//   averageCPH: 0,\n//   averageUptime: 0,\n//   headCount: 0,\n//   status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n//   error: null\n// };\n\n// // // Async thunk to fetch metrics\n// // export const fetchMetrics = createAsyncThunk('metrics/fetchMetrics', async () => {\n// //   const response = await fetch('http://localhost:5555/associate_metrics');\n// //   const data = await response.json();\n// //   return data;\n// // });\n\n// // updateWorkerMetrics: (state, action) => {\n// //   const { workerId, newMetrics } = action.payload;\n// //   // Find the worker in the state and update their metrics\n// //   const workerIndex = state.workers.findIndex(worker => worker.id === workerId);\n// //   if(workerIndex !== -1) {\n// //     state.workers[workerIndex].metrics = newMetrics;\n// //     // Recalculate the global metrics\n// //     const calculatedMetrics = calculateMetrics(state.workers);\n// //     return { ...state, ...calculatedMetrics };\n// //   }\n// // },\n\n// // Extract and calculate metrics from worker data\n// const calculateMetrics = (workers) => {\n//   let transformedWorkers = workers.map(worker => ({\n//     attendance: worker.metrics.find(m => m.metric_name === 'Attendance')?.value || 0,\n//     casesPerHour: worker.metrics.find(m => m.metric_name === 'Pallets Per Hour')?.value || 0,\n//     uptime: worker.metrics.find(m => m.metric_name === 'Uptime')?.value || 0,\n//   }));\n\n  \n//   let averageAttendance = transformedWorkers.reduce((sum, w) => sum + Number(w.attendance), 0) / (transformedWorkers.length || 1)\n//   let averageCPH = transformedWorkers.reduce((sum, w) => sum + Number(w.casesPerHour), 0) / (transformedWorkers.length || 1)\n//   let averageUptime = transformedWorkers.reduce((sum, w) => sum + Number(w.uptime), 0) / (transformedWorkers.length || 1)\n//   let headCount = workers.length\n//   let totalCapacity = headCount*averageAttendance*averageCPH * averageUptime\n\n\n\n//   return {\n//     totalCapacity,\n//     averageAttendance,\n//     averageCPH,\n//     averageUptime,\n//     headCount\n//   };\n// };\n\n// const metricsSlice = createSlice({\n//   name: 'metrics',\n//   initialState,\n//   reducers: {\n//     // Reducer to manually set metrics\n//     setMetrics: (state, action) => {\n//       return { ...state, ...action.payload };\n//     },\n//   },\n//   extraReducers: (builder) => {\n//     builder\n//       .addCase(fetchMetrics.pending, (state, action) => {\n//         state.status = 'loading';\n//       })\n\n//       .addCase(fetchMetrics.fulfilled, (state, action) => {\n//         state.status = 'succeeded';\n//         state.workers = action.payload;\n//         if (!Array.isArray(action.payload)) {\n//           state.error = 'Data received is not an array';\n//           return;\n//         }\n//         const newMetrics = calculateMetrics(action.payload);\n//         state.totalCapacity = newMetrics.totalCapacity;\n//         state.averageAttendance = newMetrics.averageAttendance;\n//         state.averageCPH = newMetrics.averageCPH;\n//         state.averageUptime = newMetrics.averageUptime;\n//         state.headCount = newMetrics.headCount;\n//       })\n//       .addCase(fetchMetrics.rejected, (state, action) => {\n//         state.status = 'failed';\n//         state.error = action.error.message;\n//       });\n//   }\n// });\n\n\n// export const { setMetrics } = metricsSlice.actions;\n\n// export const updateMetrics = (workers) => (dispatch) => {\n//   const metrics = calculateMetrics(workers);\n//   dispatch(setMetrics(metrics));\n// };\n\n\n// export default metricsSlice.reducer;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;;AAGA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}