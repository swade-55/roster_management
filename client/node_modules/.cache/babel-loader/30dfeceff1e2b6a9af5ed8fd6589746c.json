{"ast":null,"code":"// metricsSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\n// Define the initial state with additional properties\nconst initialState = {\n  workers: [],\n  totalCapacity: 0,\n  averageAttendance: 0,\n  averageCPH: 0,\n  averageUptime: 0,\n  headCount: 0,\n  status: 'idle',\n  // 'idle' | 'loading' | 'succeeded' | 'failed'\n  error: null\n};\n\n// Async thunk to fetch metrics\nexport const fetchMetrics = createAsyncThunk('metrics/fetchMetrics', async () => {\n  const response = await axios.get('/associate_metrics');\n  return response.data;\n});\n\n// Extract and calculate metrics from worker data\nconst calculateMetrics = workers => {\n  // The structure of the workers array needs to be taken into account.\n  // It seems the workers array contains objects with a metrics property that is an array.\n  // You would first need to transform this structure to match what calculateMetrics expects.\n  let transformedWorkers = workers.map(worker => {\n    let metrics = {\n      attendance: 0,\n      casesPerHour: 0,\n      uptime: 0\n    };\n    worker.metrics.forEach(metric => {\n      if (metric.metric_name === 'Attendance') metrics.attendance = metric.value;\n      if (metric.metric_name === 'Pallets Per Hour') metrics.casesPerHour = metric.value;\n      if (metric.metric_name === 'Uptime') metrics.uptime = metric.value;\n    });\n    return metrics;\n  });\n  return {\n    totalCapacity: 0,\n    // Implement logic to calculate totalCapacity if needed\n    averageAttendance: transformedWorkers.reduce((sum, worker) => sum + worker.attendance, 0) / transformedWorkers.length,\n    averageCPH: transformedWorkers.reduce((sum, worker) => sum + worker.casesPerHour, 0) / transformedWorkers.length,\n    averageUptime: transformedWorkers.reduce((sum, worker) => sum + worker.uptime, 0) / transformedWorkers.length,\n    headCount: workers.length\n  };\n};\nconst metricsSlice = createSlice({\n  name: 'metrics',\n  initialState,\n  reducers: {\n    setMetrics: (state, action) => {\n      return {\n        ...state,\n        ...action.payload\n      };\n    }\n  },\n  extraReducers: {\n    [fetchMetrics.pending]: (state, action) => {\n      state.status = 'loading';\n    },\n    [fetchMetrics.fulfilled]: (state, action) => {\n      state.status = 'succeeded';\n      state.workers = action.payload;\n      // Assuming your server response structure matches your state structure.\n      // Otherwise, you would transform the response here before assigning.\n      const newMetrics = calculateMetrics(action.payload);\n      state.totalCapacity = newMetrics.totalCapacity;\n      state.averageAttendance = newMetrics.averageAttendance;\n      state.averageCPH = newMetrics.averageCPH;\n      state.averageUptime = newMetrics.averageUptime;\n      state.headCount = newMetrics.headCount;\n    },\n    [fetchMetrics.rejected]: (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message;\n    }\n  }\n});\nexport const {\n  setMetrics\n} = metricsSlice.actions;\nexport const updateMetrics = workers => dispatch => {\n  const metrics = calculateMetrics(workers);\n  dispatch(setMetrics(metrics));\n};\nexport default metricsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","axios","initialState","workers","totalCapacity","averageAttendance","averageCPH","averageUptime","headCount","status","error","fetchMetrics","response","get","data","calculateMetrics","transformedWorkers","map","worker","metrics","attendance","casesPerHour","uptime","forEach","metric","metric_name","value","reduce","sum","length","metricsSlice","name","reducers","setMetrics","state","action","payload","extraReducers","pending","fulfilled","newMetrics","rejected","message","actions","updateMetrics","dispatch","reducer"],"sources":["/home/samuelrcwade/Development/Code/Phase4/roster_management/client/src/features/metricsSlice.js"],"sourcesContent":["// metricsSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\n// Define the initial state with additional properties\nconst initialState = {\n  workers: [],\n  totalCapacity: 0,\n  averageAttendance: 0,\n  averageCPH: 0,\n  averageUptime: 0,\n  headCount: 0,\n  status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n  error: null\n};\n\n// Async thunk to fetch metrics\nexport const fetchMetrics = createAsyncThunk('metrics/fetchMetrics', async () => {\n  const response = await axios.get('/associate_metrics');\n  return response.data;\n});\n\n// Extract and calculate metrics from worker data\nconst calculateMetrics = (workers) => {\n  // The structure of the workers array needs to be taken into account.\n  // It seems the workers array contains objects with a metrics property that is an array.\n  // You would first need to transform this structure to match what calculateMetrics expects.\n  let transformedWorkers = workers.map(worker => {\n    let metrics = {\n      attendance: 0,\n      casesPerHour: 0,\n      uptime: 0\n    };\n\n    worker.metrics.forEach(metric => {\n      if (metric.metric_name === 'Attendance') metrics.attendance = metric.value;\n      if (metric.metric_name === 'Pallets Per Hour') metrics.casesPerHour = metric.value;\n      if (metric.metric_name === 'Uptime') metrics.uptime = metric.value;\n    });\n\n    return metrics;\n  });\n\n  return {\n    totalCapacity: 0, // Implement logic to calculate totalCapacity if needed\n    averageAttendance: transformedWorkers.reduce((sum, worker) => sum + worker.attendance, 0) / transformedWorkers.length,\n    averageCPH: transformedWorkers.reduce((sum, worker) => sum + worker.casesPerHour, 0) / transformedWorkers.length,\n    averageUptime: transformedWorkers.reduce((sum, worker) => sum + worker.uptime, 0) / transformedWorkers.length,\n    headCount: workers.length\n  };\n};\n\nconst metricsSlice = createSlice({\n  name: 'metrics',\n  initialState,\n  reducers: {\n    setMetrics: (state, action) => {\n      return { ...state, ...action.payload };\n    },\n  },\n  extraReducers: {\n    [fetchMetrics.pending]: (state, action) => {\n      state.status = 'loading';\n    },\n    [fetchMetrics.fulfilled]: (state, action) => {\n      state.status = 'succeeded';\n      state.workers = action.payload;\n      // Assuming your server response structure matches your state structure.\n      // Otherwise, you would transform the response here before assigning.\n      const newMetrics = calculateMetrics(action.payload);\n      state.totalCapacity = newMetrics.totalCapacity;\n      state.averageAttendance = newMetrics.averageAttendance;\n      state.averageCPH = newMetrics.averageCPH;\n      state.averageUptime = newMetrics.averageUptime;\n      state.headCount = newMetrics.headCount;\n    },\n    [fetchMetrics.rejected]: (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message;\n    },\n  },\n});\n\nexport const { setMetrics } = metricsSlice.actions;\n\nexport const updateMetrics = (workers) => (dispatch) => {\n  const metrics = calculateMetrics(workers);\n  dispatch(setMetrics(metrics));\n};\n\nexport default metricsSlice.reducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}