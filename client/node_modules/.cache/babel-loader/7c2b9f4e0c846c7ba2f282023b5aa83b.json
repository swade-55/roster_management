{"ast":null,"code":"// metricsSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\n// Define the initial state with additional properties\nconst initialState = {\n  workers: [],\n  totalCapacity: 0,\n  averageAttendance: 0,\n  averageCPH: 0,\n  averageUptime: 0,\n  headCount: 0,\n  status: 'idle',\n  // 'idle' | 'loading' | 'succeeded' | 'failed'\n  error: null\n};\n\n// Async thunk to fetch metrics\n// export const fetchMetrics = createAsyncThunk('metrics/fetchMetrics', async () => {\n//   const response = await axios.get('/associate_metrics');\n//   return response.data;\n// });\n\n// Extract and calculate metrics from worker data\nconst calculateMetrics = workers => {\n  // The structure of the workers array needs to be taken into account.\n  // It seems the workers array contains objects with a metrics property that is an array.\n  // You would first need to transform this structure to match what calculateMetrics expects.\n  let transformedWorkers = workers.map(worker => {\n    let metrics = {\n      attendance: 0,\n      casesPerHour: 0,\n      uptime: 0\n    };\n    worker.metrics.forEach(metric => {\n      if (metric.metric_name === 'Attendance') metrics.attendance = metric.value;\n      if (metric.metric_name === 'Pallets Per Hour') metrics.casesPerHour = metric.value;\n      if (metric.metric_name === 'Uptime') metrics.uptime = metric.value;\n    });\n    return metrics;\n  });\n  return {\n    totalCapacity: 0,\n    // Implement logic to calculate totalCapacity if needed\n    averageAttendance: transformedWorkers.reduce((sum, worker) => sum + worker.attendance, 0) / transformedWorkers.length,\n    averageCPH: transformedWorkers.reduce((sum, worker) => sum + worker.casesPerHour, 0) / transformedWorkers.length,\n    averageUptime: transformedWorkers.reduce((sum, worker) => sum + worker.uptime, 0) / transformedWorkers.length,\n    headCount: workers.length\n  };\n};\nconst metricsSlice = createSlice({\n  name: 'metrics',\n  initialState,\n  reducers: {\n    setMetrics: (state, action) => {\n      return {\n        ...state,\n        ...action.payload\n      };\n    }\n  },\n  extraReducers: {\n    [fetchMetrics.pending]: (state, action) => {\n      state.status = 'loading';\n    },\n    [fetchMetrics.fulfilled]: (state, action) => {\n      state.status = 'succeeded';\n      state.workers = action.payload;\n      // Assuming your server response structure matches your state structure.\n      // Otherwise, you would transform the response here before assigning.\n      const newMetrics = calculateMetrics(action.payload);\n      state.totalCapacity = newMetrics.totalCapacity;\n      state.averageAttendance = newMetrics.averageAttendance;\n      state.averageCPH = newMetrics.averageCPH;\n      state.averageUptime = newMetrics.averageUptime;\n      state.headCount = newMetrics.headCount;\n    },\n    [fetchMetrics.rejected]: (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message;\n    }\n  }\n});\nexport const {\n  setMetrics\n} = metricsSlice.actions;\nexport const updateMetrics = workers => dispatch => {\n  const metrics = calculateMetrics(workers);\n  dispatch(setMetrics(metrics));\n};\nexport default metricsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","axios","initialState","workers","totalCapacity","averageAttendance","averageCPH","averageUptime","headCount","status","error","calculateMetrics","transformedWorkers","map","worker","metrics","attendance","casesPerHour","uptime","forEach","metric","metric_name","value","reduce","sum","length","metricsSlice","name","reducers","setMetrics","state","action","payload","extraReducers","fetchMetrics","pending","fulfilled","newMetrics","rejected","message","actions","updateMetrics","dispatch","reducer"],"sources":["/home/samuelrcwade/Development/Code/Phase4/roster_management/client/src/features/metricsSlice.js"],"sourcesContent":["// metricsSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\n// Define the initial state with additional properties\nconst initialState = {\n  workers: [],\n  totalCapacity: 0,\n  averageAttendance: 0,\n  averageCPH: 0,\n  averageUptime: 0,\n  headCount: 0,\n  status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n  error: null\n};\n\n// Async thunk to fetch metrics\n// export const fetchMetrics = createAsyncThunk('metrics/fetchMetrics', async () => {\n//   const response = await axios.get('/associate_metrics');\n//   return response.data;\n// });\n\n// Extract and calculate metrics from worker data\nconst calculateMetrics = (workers) => {\n  // The structure of the workers array needs to be taken into account.\n  // It seems the workers array contains objects with a metrics property that is an array.\n  // You would first need to transform this structure to match what calculateMetrics expects.\n  let transformedWorkers = workers.map(worker => {\n    let metrics = {\n      attendance: 0,\n      casesPerHour: 0,\n      uptime: 0\n    };\n\n    worker.metrics.forEach(metric => {\n      if (metric.metric_name === 'Attendance') metrics.attendance = metric.value;\n      if (metric.metric_name === 'Pallets Per Hour') metrics.casesPerHour = metric.value;\n      if (metric.metric_name === 'Uptime') metrics.uptime = metric.value;\n    });\n\n    return metrics;\n  });\n\n  return {\n    totalCapacity: 0, // Implement logic to calculate totalCapacity if needed\n    averageAttendance: transformedWorkers.reduce((sum, worker) => sum + worker.attendance, 0) / transformedWorkers.length,\n    averageCPH: transformedWorkers.reduce((sum, worker) => sum + worker.casesPerHour, 0) / transformedWorkers.length,\n    averageUptime: transformedWorkers.reduce((sum, worker) => sum + worker.uptime, 0) / transformedWorkers.length,\n    headCount: workers.length\n  };\n};\n\nconst metricsSlice = createSlice({\n  name: 'metrics',\n  initialState,\n  reducers: {\n    setMetrics: (state, action) => {\n      return { ...state, ...action.payload };\n    },\n  },\n  extraReducers: {\n    [fetchMetrics.pending]: (state, action) => {\n      state.status = 'loading';\n    },\n    [fetchMetrics.fulfilled]: (state, action) => {\n      state.status = 'succeeded';\n      state.workers = action.payload;\n      // Assuming your server response structure matches your state structure.\n      // Otherwise, you would transform the response here before assigning.\n      const newMetrics = calculateMetrics(action.payload);\n      state.totalCapacity = newMetrics.totalCapacity;\n      state.averageAttendance = newMetrics.averageAttendance;\n      state.averageCPH = newMetrics.averageCPH;\n      state.averageUptime = newMetrics.averageUptime;\n      state.headCount = newMetrics.headCount;\n    },\n    [fetchMetrics.rejected]: (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message;\n    },\n  },\n});\n\nexport const { setMetrics } = metricsSlice.actions;\n\nexport const updateMetrics = (workers) => (dispatch) => {\n  const metrics = calculateMetrics(workers);\n  dispatch(setMetrics(metrics));\n};\n\nexport default metricsSlice.reducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}